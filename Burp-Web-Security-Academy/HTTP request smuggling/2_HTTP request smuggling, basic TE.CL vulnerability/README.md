# Lab: HTTP request smuggling, basic TE.CL vulnerability
https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl

## Phân tích

- Xác định method phía FE:
  - X là 1 invalid chunk size, vì mong muốn chunk tiếp theo phải là hexadecimal (xác định số bytes của chunked), nhưng đây là 1 ký tự
  - Vì chunked message ko đúng nên ta xác định đc FE dùng TE
  
![img.png](img.png)

![img_1.png](img_1.png)
**Note:** quay lại lab trước (CL.TE), thì request gởi chunked message sai nhưng FE chỉ verify CL nên request vẫn gởi đi được, và do BE verify TE, mà TE ko đúng nên nó chờ chunked tiếp cho đến timeout. 

- Xác định method phía BE:
  - Do FE dùng TE, sau chunk size = 0 thì nó nghĩ là hết chunked message nên nó forward đến BE (chỉ 5 bytes, drop bytes thứ 6 là X)
  - Và do BE dùng CL để verify (6 bytes) nên nó đợi bytes thứ 6 đến, đợi đến timeout

![img_2.png](img_2.png)

![img_3.png](img_3.png)

## Xác nhận lại TE.CL

![img_4.png](img_4.png)

## Resolve lab

![img_7.png](img_7.png)

Continue to send a normal request

![img_6.png](img_6.png)

The lab solution uses Content-Length 6, which works fine as well. It's greater than "actual_content_length + 1", and it's less than "actual_content_length + length of content of our own normal request or a victim's normal request".

- Case with maximum CL: "actual_content_length + length of content of our own normal request or a victim's normal request".

- Normal request với CL = 152
![img_8.png](img_8.png)
- Attach CL có sẵn 5 , cộng với 152 là 157 ==> Max = 157
![img_9.png](img_9.png)
- Gởi attack rq xong đến normal rq: WORK
![img_10.png](img_10.png)

- Nếu max CL = 158 --> timeout, vì BE dùng CL, mà CL là 158 trong khi message có 157, nó đang chờ tiếp 1 byte, chờ đến timeout
![img_11.png](img_11.png)

![img_12.png](img_12.png)